<html>

<body>
    <script>
        let arr = ["I", "go", "home"];

        delete arr[1]; //go

        alert(arr[1]); //undefined
        // arr의 상태가 ["I", , "home"]; 가 되었기 때문

        alert(arr.length); //3 길이는 여전히 3

        /*====================================================*/

        let arr1 = ["I", "study", "JavaScript"];

        arr1.splice(1, 1); //1번 부터 1개의 요소를 제거하라

        alert(arr); //["I","JavaScript"];

        /*====================================================*/

        let arr2 = ["I", "study", "JavaScript", "right", "now"];

        arr.splice(0, 3, "Let's", "go")

        alert(arr2); //["Let's","go","right","now"];

        /*====================================================*/

        let arr3 = ["I", "study", "JavaScript", "right", "now"];

        let removed = arr3.splice(0, 2);

        alert(removed); //"I","study";

        /*====================================================*/

        let arr4 = ["I", "study", "JavaScript"];

        arr4.splice(2, 0, "어려운", "언어");
        //2번인덱스 부터 0아무것도 삭제 하지 않고 "어려운","언어"를 추가한다.

        alert(arr4);

        /*====================================================*/

        let arr5 = [1, 2, 5];

        arr5.splice(-1, 0, 3, 4);
        //-1(끝에서 첫번째 = 5)부터 0(아무것도 삭제 안함) 3,4를 추가한다.

        alert(arr5); //[1, 2, 3, 4, 5]

        /*====================================================*/

        let arr6 = ["tesa", "tese", "tesq", "test"];
        arr6.slice(1, 3);
        //"tese","tesq" //1번 ~ 2번 인덱스 까지를 반환한다. 3은 포함 하지 않는다.
        arr6.slice(-2);
        //"tesq","test" //인덱스 -2(끝에서 두번째)부터 끝 요소 까지 반환한다.

        /*====================================================*/

        //concat : 인자를 받아 새로운 배열을 만든다.
        let arr7 = [1, 2];
        arr7.concat([3, 4]); //1, 2, 3, 4;
        arr7.concat([3, 4], [5, 6]) //1, 2, 3, 4, 5, 6;
        arr7.concat([3, 4], [5, 6], 7, 8) //1, 2, 3, 4, 5 ,6 ,7 ,8;

        let arr8 = [1, 2];
        let arrayLike = {
            0: "something",
            length: 1
        };

        arr8.concat(arrayLike); //1,2,[object, object];
        //concat은 배열의 요소를 복사해 활용하는데 
        //객체가 인자로 넘어오면 객체의 요소가 아닌 객체가 통으로 복사된다.

        let arrayLike2 = {
            0: "something",
            1: "else",
            [Symbol.isConcatSpreadable]: true,
            length: 2
        };

        arr8.concat(arrayLike2); //1,2,something,else
        //인자로 받은 유사 배열 객체에 특수한 프로퍼티 [Symbol.isConcatSpreadable]가 있으면
        // concat은 이 객체를 배열처럼 취급하므로 객체 프로퍼티의 값이 더해집니다.

        /*====================================================*/

        let arr9 = ["가", "나", "다", "라", "마", "바", "사", "아", "자"];

        arr9.forEach((item) => {
            alert(`${item}아`);
        });

        arr9.forEach((item, index) => {
            alert(`${item}아 + ${index}`);
        });

        arr9.forEach((item, index, array) => {
            alert(`${item}아 + ${index} in ${array}`)
        });
        /*====================================================*/

        let arr10 = ["aaa", "bbb", "ccc", "ddd", "fff", NaN];
        arr10.indexOf("fff"); //4 위치를 반환해 줍니다.
        arr10.indexOf("qqq"); //-1 찾지 못하면 -1을 반환해 줍니다.
        arr10.includes("aaa"); //true, false로 반환 받으려면 includes를 사용한다.

        arr10.indexOf(NaN) //-1 완전 항등 비교 === 는 NaN에는 동작하지 않으므로 위치가 반환되지 않습니다.
        arr10.includes(NaN) //true

        /*====================================================*/

        let arr11s = [{
            id: 1,
            name: "John"
        }, {
            id: 2,
            name: "Pete"
        }, {
            id: 3,
            name: "Mary"
        }];

        let arr11 = arr11s.find(item => item.id < 3);

        alert(arr11.name); //John //find는 조건에 맞는 첫번째 요소만 반환해준다.
        alert(arr11); //{id: 1, name: "John"}

        /*====================================================*/

        let arr12s = [{
            id: 1,
            name: "John"
        }, {
            id: 2,
            name: "Pete"
        }, {
            id: 3,
            name: "Mary"
        }]

        let arr12 = arr12s.filter(item => item.id < 3);

        alert(arr12.name); //John,Pete //filter는 조건에 맞는 모든 요소를 반환해준다
        alert(arr12);

        /*====================================================*/

        //map은 요소 전체를 순회하며 함수에 대입하고 함수 결과를 배열로 반환 해준다.
        let arr13s = ["Bilbo", "Gandalf", "Nazgul"];
        let arrLength = arr13s.map(item => item.length);

        console.log(arrLength); //5,7,6

        /*====================================================*/

        let arr14 = [1, 2, 3, 7, 6, 6, 5, 4, 9, 16];

        arr14.sort(); // 1, 16, 2, 3, 4, 5, 6, 6, 7, 9; //요소가 문자열로 취깁되어 재정렬 하기 때문에 순서가 이상해짐

        let compare = (a, b) => { //정렬을 할때 정렬의 기준을 정해햐 한다. 
            if (a > b) return 1; //숫자로이루어진 문자열을 비교하면 숫자타입으로 비교한다.//1 을 -1로 바꾸면 내림차순이 된다.
            if (a == b) return 0;
            if (a < b) return -1; // -1을 1로 바꾸면 내림차순이 된다.
        }

        //서로 비교 했을때 첫번째 인수가 두번째 인수보다 크면 양수를 반환하면 되고 반대면 음수를 반환해주기만 하면 정렬의 기준이 될수 있다.
        arr14.sort((a, b) => a - b);

        console.log(arr14.sort(compare));

        /*====================================================*/

        let arr15 = [1, 2, 3, 4, 5];
        console.log(arr15.reverse()); //5,4,3,2,1 //역순으로 정렬 해주는 메소드

        /*====================================================*/

        let arr16 = '1, 2, 3, 4, 5, 6, 7, 8';

        let arr = arr16.split(', '); //split의 인자를 기준으로 문자열을 잘라 배열로 반환해줌

        for (let item of arr) {
            console.log(item);
        }
        /*
        1
        2
        3
        4
        5
        6
        7
        8
        */

        /*====================================================*/

        let arr17 = '1, 2, 3, 4, 5, 6, 7, 8';

        let arr = arr17.split(', ', 4); //두번째 인자의 숫자 만큼만 배열에 담아준다.

        for (let item of arr) {
            console.log(item);
        }
        /*
        1
        2
        3
        4
        */

        /*====================================================*/

        let arr18 = ['abc', 'def', 'ghi', 'jkl'];

        let str = arr18.join('');
        let str1 = arr18.join(',');
        let str2 = arr18.join(' ');
        let str3 = arr18.join();
        console.log(str); //abcdefghijkl
        console.log(str1); //abc,def,ghi,jkl
        console.log(str2); //abc def ghi jkl
        console.log(str3); //abc,def,ghi,jkl

        /*====================================================*/

        let arr19 = [1, 2, 3, 4, 5];

        let result = arr.reduce((sum, current) => sum + current, 0); //0은 초기값
        //맨 처음 초기값 0이 sum에 저장되고 current에 배열의 첫번째 요소 1이 들어가서 0 + 1 을 sum에 더한다.
        //다음 sum = 1이고, current는 두번쨰 요소 2가 들어가서 1 + 2를 sum에 더한다.
        //반복후 결과를 result에 저장.

        let result = arr.reduce((sum, current) => sum + current); //초기값이 없어도 작동 가능
        //초기값이 없으면 배열의 첫번째 요소가 sum에 들어가고 두번째 요소부터 함수를 호출한다.

        /*====================================================*/

        //배열인지 확인하는 메서드
        console.log(Array.isArray([])) //true
        console.log(Array.isArray({})) //false

        /*====================================================*/

        let army = {
            minAge: 18,
            maxAge: 27,
            canJoin(user) {
                return user.age >= this.minAge && user.age < this.maxAge;
            }
        };

        let users = [{
            age: 16
        }, {
            age: 20
        }, {
            age: 23
        }, {
            age: 30
        }];

        let soldiers = users.filter(army.canJoin, army);

        console.log(soldiers);

        let soldiers1 = users.filter(user => army.canJoin(user));
        //users의 요소를 하나씩 army.canJoin(user)에 user로 인자를 보내서 true를 반환하면 해당 요소를 soldiers1에 저장

        console.log(soldiers1);
    </script>
</body>

</html>